{
    "label":  "Commit001",
    "timestamp":  "2026-02-21T17:53:31.666105",
    "commit_hash":  "f53abc749ddcd5ff40acebcef2c111e48b7c2e9d",
    "commit_message":  "Initial commit",
    "commit_date":  "2025-09-27 11:28:00 -0500",
    "service_availability":  {
                                 "artist_service":  {
                                                        "available":  true,
                                                        "status_code":  200
                                                    },
                                 "album_service":  {
                                                       "available":  true,
                                                       "status_code":  200
                                                   },
                                 "recommendation_service":  {
                                                                "available":  true,
                                                                "status_code":  200
                                                            },
                                 "api_gateway":  {
                                                     "available":  true,
                                                     "status_code":  200
                                                 }
                             },
    "total_tests":  22,
    "passed":  15,
    "failed":  7,
    "errors":  0,
    "reliability_score":  68.18181818181817,
    "test_results":  {
                         "test_service_unavailable_returns_503_not_500":  {
                                                                              "outcome":  "passed",
                                                                              "duration":  2.081068500003312,
                                                                              "error":  null
                                                                          },
                         "test_correct_http_error_codes":  {
                                                               "outcome":  "passed",
                                                               "duration":  0.3184105999971507,
                                                               "error":  null
                                                           },
                         "test_concurrent_routing_reliability":  {
                                                                     "outcome":  "passed",
                                                                     "duration":  2.218091499991715,
                                                                     "error":  null
                                                                 },
                         "test_timeout_configuration_present":  {
                                                                    "outcome":  "failed",
                                                                    "duration":  0.0009948999941116199,
                                                                    "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_gateway.py:161: in test_timeout_configuration_present\n    assert \"TIMEOUT_CONFIG\" in content or \"timeout\" in content.lower(), \\\nE   AssertionError: No timeout configuration found in gateway\nE   assert (\u0027TIMEOUT_CONFIG\u0027 in \u0027from fastapi import FastAPI, HTTPException\\nimport httpx\\nimport uvicorn\\nimport os\\n\\napp = FastAPI(title=\"MusicBrainz API Gateway\", version=\"1.0.0\")\\n\\n# Service URLs\\nARTIST_SERVICE_URL = os.getenv(\"ARTIST_SERVICE_URL\", \"http://localhost:8001\")\\nALBUM_SERVICE_URL = os.getenv(\"ALBUM_SERVICE_URL\", \"http://localhost:8002\")\\nRECOMMENDATION_SERVICE_URL = os.getenv(\"RECOMMENDATION_SERVICE_URL\", \"http://localhost:8003\")\\n\\n@app.get(\"/health\")\\ndef health_check():\\n    return {\"status\": \"healthy\", \"service\": \"api-gateway\"}\\n\\n# Artist endpoints\\n@app.get(\"/api/artists/search\")\\nasync def search_artists(query: str, limit: int = 25):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{ARTIST_SERVICE_URL}/artists/search\", params={\"query\": query, \"limit\": limit})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\n@app.get(\"/api/artists/{artist_id}\")\\nasync def get_artist(artist_id: str):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{ARTIST_SERVICE_URL}/artists/{artist_id}\")\\n        if respons...n()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\n@app.get(\"/api/users/{username}/profile\")\\nasync def get_user_profile(username: str):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{RECOMMENDATION_SERVICE_URL}/users/{username}/profile\")\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Profile not found\")\\n\\n@app.post(\"/api/users/{username}/listening-history\")\\nasync def add_listening_history(username: str, track_id: str, artist_id: str, interaction_type: str = \"played\"):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.post(f\"{RECOMMENDATION_SERVICE_URL}/users/{username}/listening-history\",\\n                                   params={\"track_id\": track_id, \"artist_id\": artist_id, \"interaction_type\": interaction_type})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\nif __name__ == \"__main__\":\\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\\n\u0027 or \u0027timeout\u0027 in \u0027from fastapi import fastapi, httpexception\\nimport httpx\\nimport uvicorn\\nimport os\\n\\napp = fastapi(title=\"musicbrainz api gateway\", version=\"1.0.0\")\\n\\n# service urls\\nartist_service_url = os.getenv(\"artist_service_url\", \"http://localhost:8001\")\\nalbum_service_url = os.getenv(\"album_service_url\", \"http://localhost:8002\")\\nrecommendation_service_url = os.getenv(\"recommendation_service_url\", \"http://localhost:8003\")\\n\\n@app.get(\"/health\")\\ndef health_check():\\n    return {\"status\": \"healthy\", \"service\": \"api-gateway\"}\\n\\n# artist endpoints\\n@app.get(\"/api/artists/search\")\\nasync def search_artists(query: str, limit: int = 25):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{artist_service_url}/artists/search\", params={\"query\": query, \"limit\": limit})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\n@app.get(\"/api/artists/{artist_id}\")\\nasync def get_artist(artist_id: str):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{artist_service_url}/artists/{artist_id}\")\\n        if respons...n()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\n@app.get(\"/api/users/{username}/profile\")\\nasync def get_user_profile(username: str):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{recommendation_service_url}/users/{username}/profile\")\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"profile not found\")\\n\\n@app.post(\"/api/users/{username}/listening-history\")\\nasync def add_listening_history(username: str, track_id: str, artist_id: str, interaction_type: str = \"played\"):\\n    async with httpx.asyncclient() as client:\\n        response = await client.post(f\"{recommendation_service_url}/users/{username}/listening-history\",\\n                                   params={\"track_id\": track_id, \"artist_id\": artist_id, \"interaction_type\": interaction_type})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\nif __name__ == \"__main__\":\\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\\n\u0027)\nE    +  where \u0027from fastapi import fastapi, httpexception\\nimport httpx\\nimport uvicorn\\nimport os\\n\\napp = fastapi(title=\"musicbrainz api gateway\", version=\"1.0.0\")\\n\\n# service urls\\nartist_service_url = os.getenv(\"artist_service_url\", \"http://localhost:8001\")\\nalbum_service_url = os.getenv(\"album_service_url\", \"http://localhost:8002\")\\nrecommendation_service_url = os.getenv(\"recommendation_service_url\", \"http://localhost:8003\")\\n\\n@app.get(\"/health\")\\ndef health_check():\\n    return {\"status\": \"healthy\", \"service\": \"api-gateway\"}\\n\\n# artist endpoints\\n@app.get(\"/api/artists/search\")\\nasync def search_artists(query: str, limit: int = 25):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{artist_service_url}/artists/search\", params={\"query\": query, \"limit\": limit})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\n@app.get(\"/api/artists/{artist_id}\")\\nasync def get_artist(artist_id: str):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{artist_service_url}/artists/{artist_id}\")\\n        if respons...n()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\n@app.get(\"/api/users/{username}/profile\")\\nasync def get_user_profile(username: str):\\n    async with httpx.asyncclient() as client:\\n        response = await client.get(f\"{recommendation_service_url}/users/{username}/profile\")\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"profile not found\")\\n\\n@app.post(\"/api/users/{username}/listening-history\")\\nasync def add_listening_history(username: str, track_id: str, artist_id: str, interaction_type: str = \"played\"):\\n    async with httpx.asyncclient() as client:\\n        response = await client.post(f\"{recommendation_service_url}/users/{username}/listening-history\",\\n                                   params={\"track_id\": track_id, \"artist_id\": artist_id, \"interaction_type\": interaction_type})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise httpexception(status_code=response.status_code, detail=\"service unavailable\")\\n\\nif __name__ == \"__main__\":\\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\\n\u0027 = \u003cbuilt-in method lower of str object at 0x0000021E93D6C030\u003e()\nE    +    where \u003cbuilt-in method lower of str object at 0x0000021E93D6C030\u003e = \u0027from fastapi import FastAPI, HTTPException\\nimport httpx\\nimport uvicorn\\nimport os\\n\\napp = FastAPI(title=\"MusicBrainz API Gateway\", version=\"1.0.0\")\\n\\n# Service URLs\\nARTIST_SERVICE_URL = os.getenv(\"ARTIST_SERVICE_URL\", \"http://localhost:8001\")\\nALBUM_SERVICE_URL = os.getenv(\"ALBUM_SERVICE_URL\", \"http://localhost:8002\")\\nRECOMMENDATION_SERVICE_URL = os.getenv(\"RECOMMENDATION_SERVICE_URL\", \"http://localhost:8003\")\\n\\n@app.get(\"/health\")\\ndef health_check():\\n    return {\"status\": \"healthy\", \"service\": \"api-gateway\"}\\n\\n# Artist endpoints\\n@app.get(\"/api/artists/search\")\\nasync def search_artists(query: str, limit: int = 25):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{ARTIST_SERVICE_URL}/artists/search\", params={\"query\": query, \"limit\": limit})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\n@app.get(\"/api/artists/{artist_id}\")\\nasync def get_artist(artist_id: str):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{ARTIST_SERVICE_URL}/artists/{artist_id}\")\\n        if respons...n()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\n@app.get(\"/api/users/{username}/profile\")\\nasync def get_user_profile(username: str):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.get(f\"{RECOMMENDATION_SERVICE_URL}/users/{username}/profile\")\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Profile not found\")\\n\\n@app.post(\"/api/users/{username}/listening-history\")\\nasync def add_listening_history(username: str, track_id: str, artist_id: str, interaction_type: str = \"played\"):\\n    async with httpx.AsyncClient() as client:\\n        response = await client.post(f\"{RECOMMENDATION_SERVICE_URL}/users/{username}/listening-history\",\\n                                   params={\"track_id\": track_id, \"artist_id\": artist_id, \"interaction_type\": interaction_type})\\n        if response.status_code == 200:\\n            return response.json()\\n        raise HTTPException(status_code=response.status_code, detail=\"Service unavailable\")\\n\\nif __name__ == \"__main__\":\\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\\n\u0027.lower"
                                                                },
                         "test_rate_limit_delay_enforced":  {
                                                                "outcome":  "passed",
                                                                "duration":  3.003148300005705,
                                                                "error":  null
                                                            },
                         "test_rate_limit_429_handling":  {
                                                              "outcome":  "passed",
                                                              "duration":  0.0010365000052843243,
                                                              "error":  null
                                                          },
                         "test_rapid_request_service_stability":  {
                                                                      "outcome":  "passed",
                                                                      "duration":  8.679264700011117,
                                                                      "error":  null
                                                                  },
                         "test_rate_limit_recovery":  {
                                                          "outcome":  "passed",
                                                          "duration":  1.0028032999980496,
                                                          "error":  null
                                                      },
                         "test_timeout_returns_empty_not_crash":  {
                                                                      "outcome":  "passed",
                                                                      "duration":  0.000526999996509403,
                                                                      "error":  null
                                                                  },
                         "test_recommendation_service_timeout_handling":  {
                                                                              "outcome":  "passed",
                                                                              "duration":  0.8753385999880265,
                                                                              "error":  null
                                                                          },
                         "test_gateway_timeout_isolation":  {
                                                                "outcome":  "passed",
                                                                "duration":  1.919951999996556,
                                                                "error":  null
                                                            },
                         "test_genre_detection_known_genres":  {
                                                                   "outcome":  "failed",
                                                                   "duration":  0.04321670001081657,
                                                                   "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_recommendation_service.py:36: in test_genre_detection_known_genres\n    from services.recommendation_service import detect_genre_enhanced\nE   ImportError: cannot import name \u0027detect_genre_enhanced\u0027 from \u0027services.recommendation_service\u0027 (C:\\Users\\dennyr\\Dropbox\\Education\\Southern Methodist University\\Courses\\Software Architecture \u0026 Design CS7319\\Project\\musicbrainz-app_old_f53abc74\\services\\recommendation_service.py)"
                                                               },
                         "test_genre_detection_none_for_unknown":  {
                                                                       "outcome":  "failed",
                                                                       "duration":  0.00012570001126732677,
                                                                       "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_recommendation_service.py:71: in test_genre_detection_none_for_unknown\n    from services.recommendation_service import detect_genre_enhanced\nE   ImportError: cannot import name \u0027detect_genre_enhanced\u0027 from \u0027services.recommendation_service\u0027 (C:\\Users\\dennyr\\Dropbox\\Education\\Southern Methodist University\\Courses\\Software Architecture \u0026 Design CS7319\\Project\\musicbrainz-app_old_f53abc74\\services\\recommendation_service.py)"
                                                                   },
                         "test_diversity_filter_max_per_artist":  {
                                                                      "outcome":  "failed",
                                                                      "duration":  0.00011770000855904073,
                                                                      "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_recommendation_service.py:101: in test_diversity_filter_max_per_artist\n    from services.recommendation_service import ensure_artist_diversity\nE   ImportError: cannot import name \u0027ensure_artist_diversity\u0027 from \u0027services.recommendation_service\u0027 (C:\\Users\\dennyr\\Dropbox\\Education\\Southern Methodist University\\Courses\\Software Architecture \u0026 Design CS7319\\Project\\musicbrainz-app_old_f53abc74\\services\\recommendation_service.py)"
                                                                  },
                         "test_diversity_ratio_in_api_response":  {
                                                                      "outcome":  "passed",
                                                                      "duration":  1.958753999992041,
                                                                      "error":  null
                                                                  },
                         "test_empty_results_graceful_response":  {
                                                                      "outcome":  "passed",
                                                                      "duration":  0.21385169999848586,
                                                                      "error":  null
                                                                  },
                         "test_fallback_strategies_activated":  {
                                                                    "outcome":  "failed",
                                                                    "duration":  0.00012870000500697643,
                                                                    "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_recommendation_service.py:212: in test_fallback_strategies_activated\n    from services.recommendation_service import get_diverse_recommendations\nE   ImportError: cannot import name \u0027get_diverse_recommendations\u0027 from \u0027services.recommendation_service\u0027 (C:\\Users\\dennyr\\Dropbox\\Education\\Southern Methodist University\\Courses\\Software Architecture \u0026 Design CS7319\\Project\\musicbrainz-app_old_f53abc74\\services\\recommendation_service.py)"
                                                                },
                         "test_profile_save_and_retrieve":  {
                                                                "outcome":  "passed",
                                                                "duration":  0.06350810000731144,
                                                                "error":  null
                                                            },
                         "test_profile_update_overwrites_correctly":  {
                                                                          "outcome":  "passed",
                                                                          "duration":  0.09546209999825805,
                                                                          "error":  null
                                                                      },
                         "test_profile_json_serialization":  {
                                                                 "outcome":  "failed",
                                                                 "duration":  0.04726420000952203,
                                                                 "error":  "C:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:145: in __init__\n    self._dbapi_connection = engine.raw_connection()\n                             ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:3292: in raw_connection\n    return self.pool.connect()\n           ^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:452: in connect\n    return _ConnectionFairy._checkout(self)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:1269: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:716: in checkout\n    rec = pool._do_get()\n          ^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\impl.py:169: in _do_get\n    with util.safe_reraise():\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\impl.py:167: in _do_get\n    return self._create_connection()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:393: in _create_connection\n    return _ConnectionRecord(self)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:678: in __init__\n    self.__connect()\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:902: in __connect\n    with util.safe_reraise():\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:898: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\create.py:637: in connect\n    return dialect.connect(*cargs, **cparams)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:616: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\psycopg2\\__init__.py:122: in connect\n    conn = _connect(dsn, connection_factory=connection_factory, **kwasync)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE   psycopg2.OperationalError: connection to server at \"localhost\" (::1), port 5432 failed: FATAL:  password authentication failed for user \"user\"\n\nThe above exception was the direct cause of the following exception:\n..\\musicbrainz-app\\tests\\fmea\\test_fmea_user_profile.py:140: in test_profile_json_serialization\n    session.commit()\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1969: in commit\n    trans.commit(_to_root=True)\n\u003cstring\u003e:2: in commit\n    ???\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n                ^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1256: in commit\n    self._prepare_impl()\n\u003cstring\u003e:2: in _prepare_impl\n    ???\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n                ^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1231: in _prepare_impl\n    self.session.flush()\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4312: in flush\n    self._flush(objects)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4447: in _flush\n    with util.safe_reraise():\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4408: in _flush\n    flush_context.execute()\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\unitofwork.py:466: in execute\n    rec.execute(self)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\unitofwork.py:642: in execute\n    util.preloaded.orm_persistence.save_obj(\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\persistence.py:60: in save_obj\n    for (\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\persistence.py:221: in _organize_states_for_save\n    for state, dict_, mapper, connection in _connections_for_states(\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\persistence.py:1726: in _connections_for_states\n    connection = uowtransaction.transaction.connection(base_mapper)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\u003cstring\u003e:2: in connection\n    ???\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n                ^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:995: in connection\n    return self._connection_for_bind(bind, execution_options)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\u003cstring\u003e:2: in _connection_for_bind\n    ???\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n                ^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1129: in _connection_for_bind\n    conn = self._parent._connection_for_bind(\n\u003cstring\u003e:2: in _connection_for_bind\n    ???\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n                ^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1143: in _connection_for_bind\n    conn = bind.connect()\n           ^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:3268: in connect\n    return self._connection_cls(self)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:147: in __init__\n    Connection._handle_dbapi_exception_noconnection(\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:2430: in _handle_dbapi_exception_noconnection\n    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:145: in __init__\n    self._dbapi_connection = engine.raw_connection()\n                             ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:3292: in raw_connection\n    return self.pool.connect()\n           ^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:452: in connect\n    return _ConnectionFairy._checkout(self)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:1269: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:716: in checkout\n    rec = pool._do_get()\n          ^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\impl.py:169: in _do_get\n    with util.safe_reraise():\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\impl.py:167: in _do_get\n    return self._create_connection()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:393: in _create_connection\n    return _ConnectionRecord(self)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:678: in __init__\n    self.__connect()\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:902: in __connect\n    with util.safe_reraise():\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\pool\\base.py:898: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\create.py:637: in connect\n    return dialect.connect(*cargs, **cparams)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:616: in connect\n    return self.loaded_dbapi.connect(*cargs, **cparams)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nC:\\Users\\dennyr\\anaconda3\\envs\\fmea_env\\Lib\\site-packages\\psycopg2\\__init__.py:122: in connect\n    conn = _connect(dsn, connection_factory=connection_factory, **kwasync)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE   sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at \"localhost\" (::1), port 5432 failed: FATAL:  password authentication failed for user \"user\"\nE   \nE   (Background on this error at: https://sqlalche.me/e/20/e3q8)"
                                                             },
                         "test_listening_history_saved_with_verification":  {
                                                                                "outcome":  "passed",
                                                                                "duration":  0.06926790000579786,
                                                                                "error":  null
                                                                            },
                         "test_history_without_existing_profile":  {
                                                                       "outcome":  "failed",
                                                                       "duration":  0.00011839999933727086,
                                                                       "error":  "..\\musicbrainz-app\\tests\\fmea\\test_fmea_user_profile.py:221: in test_history_without_existing_profile\n    username = f\"fmea_no_profile_user_{int(time.time())}\"\n                                           ^^^^\nE   UnboundLocalError: cannot access local variable \u0027time\u0027 where it is not associated with a value"
                                                                   }
                     }
}
